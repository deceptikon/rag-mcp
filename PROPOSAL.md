# PROPOSAL.md for Multi-Context Platform (MCP) Server

## 1. Analysis of RAG folder (Chunking and Population)

The `RAG` folder contains `scanner.py` which is responsible for chunking code and documentation files.

### Chunking Logic (from `RAG/scanner.py`)

-   Uses `langchain_text_splitters` for text splitting.
-   `RecursiveCharacterTextSplitter` is used for general code files, with language-specific configurations (Python, JavaScript, Markdown).
-   `MarkdownHeaderTextSplitter` is used for Markdown files, first splitting by headers, then recursively splitting large sections.
-   Files and directories are filtered based on `IGNORE_DIRS`, `IGNORE_FILES`, and `ALLOWED_EXTENSIONS`.
-   Metadata such as `source`, `filename`, `extension`, and `type` (e.g., 'documentation') are added to each chunk.

### Code for Chunk Creation

The core function for chunk creation is `load_and_chunk_project(root_path)` from `RAG/scanner.py`. It returns a list of `Document` objects (from `langchain`), where each document is a chunk with associated metadata.

```python
# Example usage of load_and_chunk_project from RAG/scanner.py
from RAG.scanner import load_and_chunk_project

project_root = "/path/to/your/project" # This should be the root of the codebase to be indexed
docs = load_and_chunk_project(project_root)

for doc in docs:
    print(f"Source: {doc.metadata['source']}, Type: {doc.metadata.get('type', 'code')}")
    print(f"Content: {doc.page_content[:200]}...")
```

### Initial Population of Vector Database with Codebase Context

The `RAG/main.py` currently calls `load_and_chunk_project` but lacks the code to send these chunks to a vector database. The `CTX/extensions/vector_store.py` provides this functionality using ChromaDB and LlamaIndex.

For initial population, we can leverage the `index-dir` command from `CTX/extensions/vector_store.py`. However, `index-dir` currently uses `SimpleDirectoryReader` for loading documents, which is less sophisticated than `RAG/scanner.py`'s chunking logic.

**Proposed approach for initial population:**

1.  **Direct use of `vector_store.py`'s `index-dir` (for quick start):**
    This would involve configuring the `project_id` and `path` in a `config.json` file for the project (e.g., in `$VOX_HOME/context/projects/<project_id>/config.json`) and then running:
    ```bash
    python CTX/extensions/vector_store.py index-dir <project_id>
    ```
    This uses `vector_store.py`'s internal document loading and chunking.

2.  **Integrating `RAG/scanner.py`'s chunking (recommended for quality):**
    A more robust solution would be to modify `CTX/extensions/vector_store.py` to accept chunks generated by `RAG/scanner.py`. This would involve:
    *   Creating a new command or modifying an existing one in `vector_store.py` (e.g., `index-custom` or `index-project`) that directly takes `Document` objects (or their content and metadata) generated by `RAG/scanner.py`.
    *   This command would then handle the embedding and storage into ChromaDB.

    A high-level command to trigger this might look like:
    ```bash
    # Assuming 'rag-mcp' is the new application
    rag-mcp index-project <project_id> --path /path/to/codebase
    ```
    This command would internally:
    a. Call `RAG/scanner.py:load_and_chunk_project` with `/path/to/codebase`.
    b. Pass the resulting `Document` objects to the modified `vector_store.py` logic for embedding and storage.

## 2. Analysis of CTX folder (Commands and Proposals)

### Existing Commands

**From `CTX/ctx.py` (JSONL-based context management):**

*   `ctx list`: List all projects.
*   `ctx add-doc <id> <type> <content> <title>`: Add a document to project context (stored in `docs.jsonl`).
*   `ctx get-docs <id> [type]`: Get documents from project context.
*   `ctx list-docs <id>`: List all documents for a project.

**From `CTX/extensions/vector_store.py` (ChromaDB + LlamaIndex integration):**

*   `python CTX/extensions/vector_store.py index <project_id>`: Index content from shell-generated `index.json` and `docs.jsonl`.
*   `python CTX/extensions/vector_store.py index-dir <project_id>`: Index directly from a project directory.
*   `python CTX/extensions/vector_store.py search <project_id> "query" [-n <num_results>] [-t <type>] [--json]`: Perform semantic search.
*   `python CTX/extensions/vector_store.py query <project_id> "query" [-n <num_results>] [--json]`: Perform RAG-style queries using LlamaIndex.
*   `python CTX/extensions/vector_store.py stats <project_id> [--json]`: Get collection statistics.
*   `python CTX/extensions/vector_store.py sync <project_id>`: Sync from shell index (same as `index` command).

### Proposed New Commands

Given the goal of a standalone MCP server, the new system should aim for a unified interface.

1.  **`rag-mcp index <project_id> --path /path/to/codebase`**:
    *   **Purpose:** The primary command for indexing an entire codebase into the vector database using the advanced chunking logic from `RAG/scanner.py`.
    *   **Details:** This command will orchestrate:
        *   Calling `RAG/scanner.py:load_and_chunk_project` to get the `Document` chunks.
        *   Initializing `VectorStoreManager` from `CTX/extensions/vector_store.py`.
        *   Adding these `Document` chunks to ChromaDB (possibly by creating a new method in `VectorStoreManager` like `add_documents(documents)`).
    *   **Aliases/Flags:**
        *   `--force-reindex`: To clear existing data and reindex.
        *   `--incremental`: To only index new or changed files (more advanced, can be a future enhancement).

2.  **`rag-mcp search <project_id> "query" [-n <num_results>] [-t <type>] [--json]`**:
    *   **Purpose:** Expose the semantic search functionality from `vector_store.py` through the main `rag-mcp` interface.

3.  **`rag-mcp query <project_id> "query" [-n <num_results>] [--json]`**:
    *   **Purpose:** Expose the RAG-style query functionality from `vector_store.py` through the main `rag-mcp` interface.

4.  **`rag-mcp add-doc <project_id> <type> <content> <title>`**:
    *   **Purpose:** To add specific, manually provided documents (e.g., design docs, specific instructions) directly into the vector store. This would bypass the file scanning and use `vector_store.py`'s methods for adding individual documents. This would replace the `ctx add-doc` command if `docs.jsonl` is phased out in favor of direct vector storage for all context.

5.  **`rag-mcp list-projects` / `rag-mcp project-stats <project_id>`**:
    *   **Purpose:** To manage and view status of indexed projects.

## 3. Proposal for File Structure in Resulting App (`rag-mcp`)

The new `rag-mcp` application should be a standalone project, separate from `tamga`. It will integrate the core functionalities of `RAG` and `CTX/extensions/vector_store.py`.

Here's a proposed file structure for the `rag-mcp` repository:

```
rag-mcp/
├── .gitignore
├── pyproject.toml                 # Project dependencies
├── README.md
├── main.py                        # Main CLI entry point for rag-mcp commands
├── app/                           # Core application logic (Flask server, API)
│   ├── __init__.py
│   ├── api.py                     # Flask Blueprints for API endpoints
│   ├── models.py                  # Database models (e.g., for project metadata, if needed)
│   └── services/
│       ├── __init__.py
│       ├── chunking_service.py    # Encapsulates RAG/scanner.py logic
│       └── vector_store_service.py # Encapsulates CTX/extensions/vector_store.py logic
├── config/                        # Configuration files (e.g., database connection)
│   └── settings.py
├── scripts/                       # Utility scripts, e.g., database initialization
│   └── init_db.py
├── tests/
│   ├── test_chunking.py
│   └── test_vector_store.py
└── requirements.txt               # Alternatively, use pyproject.toml for dependencies
```

**Explanation of proposed structure:**

*   **`main.py`**: This will be the CLI entry point for the `rag-mcp` tool. It will parse commands (e.g., `index`, `search`, `query`) and delegate to the appropriate services within the `app/` directory.
*   **`app/`**: Contains the main application logic.
    *   **`api.py`**: If the MCP server is to expose a REST API (as per the vision), this will define the Flask blueprints and routes.
    *   **`models.py`**: If the MCP server needs its own database for project metadata or other internal management, the SQLAlchemy/Django models would go here.
    *   **`services/`**: This directory will house the business logic, abstracting away the specifics of chunking and vector storage.
        *   **`chunking_service.py`**: This module will wrap the functionality from the original `RAG/scanner.py`. It should provide functions like `chunk_project(root_path) -> List[Document]`.
        *   **`vector_store_service.py`**: This module will wrap the functionality from the original `CTX/extensions/vector_store.py`. It should provide functions like `initialize_vector_store(project_id)`, `add_documents_to_store(project_id, documents)`, `semantic_search(project_id, query)`, etc. This service would handle the ChromaDB and LlamaIndex interactions.
*   **`config/`**: Centralized place for application settings (database URIs, API keys, etc.).
*   **`scripts/`**: For one-off setup or maintenance scripts.
*   **`tests/`**: Unit and integration tests.
*   **`pyproject.toml` / `requirements.txt`**: For dependency management.

This structure promotes modularity, testability, and separation of concerns, aligning with the goal of a reusable, project-agnostic MCP server. It explicitly integrates the existing `RAG` chunking and `CTX` vector store functionalities into a cohesive new application.

## 4. Integration of CTX Components

To clarify which parts of the `CTX` directory will be integrated into the `rag-mcp` server and which are considered client-side tools, here is a breakdown:

### Components to be Integrated into `rag-mcp`

The following files contain core logic that is essential for the `rag-mcp` server and will be integrated into the new Python application structure:

*   **`RAG/scanner.py`**: The chunking logic is fundamental and will be integrated into `app/services/chunking_service.py`.
*   **`CTX/extensions/vector_store.py`**: This is the core of the vector store management using ChromaDB and LlamaIndex. Its functionality will be integrated into `app/services/vector_store_service.py`.
*   **`CTX/ctx.py`**: The features of this script (managing documents in `docs.jsonl`) will be **re-implemented** within the `rag-mcp` application to interact directly with the vector store (or a more robust metadata database), rather than being moved as-is.

### Client-Side Components (Not to be Moved to `rag-mcp`)

The following files are part of a custom CLI front-end for the user's workflow, primarily interacting with a tool called `opencode`. They are considered **clients** of the context that `rag-mcp` will provide, and therefore should **not** be part of the `rag-mcp` server project itself.

*   **`ctx` (Zsh script)**: This is a dispatcher for the client-side tool. The `rag-mcp` server will have its own CLI entry point (`main.py`).
*   **`ocx`**, **`opencode-with-context`**, **`runocx`**: These are wrapper scripts for the `opencode` tool. They can be updated to query the `rag-mcp` server's API for context, but they do not belong in the server's codebase.
*   **`context-dispatcher.zsh`**: This is a helper script for the client-side tools and is not needed for the `rag-mcp` server.
*   Other shell scripts (`install.sh`, `agent-onboarding.sh`, etc.): These are for setting up the client-side `ctx` tool and are not relevant to the `rag-mcp` server.

By separating the core server logic from the client-side tools, we can build a clean, reusable, and maintainable Multi-Context Platform (MCP) server, as per the project vision.
